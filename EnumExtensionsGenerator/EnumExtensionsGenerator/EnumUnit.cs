using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace EnumExtensionsGenerator;

internal sealed class EnumUnit
{
    public string Filename => MakeFilename();

    private string Fullname =>
        HasNamespace
            ? $"{_namespace}.{_name}"
            : _name;

    private readonly string _name;
    private readonly string _namespace;
    private readonly string _baseType;
    private readonly string _unsignedBaseType;
    private readonly Accessibility _accessibility;
    private readonly IReadOnlyList<Member> _members;
    private readonly string? _extensionClassNamespace;
    private readonly string? _extensionClassName;
    private readonly bool _isSequential;

    private bool HasNamespace => _namespace != "";

    public static EnumUnit Create(
        INamedTypeSymbol enumSymbol,
        string? extensionClassNamespace = default,
        string? extensionClassName = default)
    {
        var @namespace = enumSymbol.ContainingNamespace.IsGlobalNamespace
            ? ""
            : enumSymbol.ContainingNamespace.ToString();

        var name = @namespace == ""
            ? enumSymbol.ConstructedFrom.ToString()
            : enumSymbol.ConstructedFrom.ToString().Substring(@namespace.Length + 1);

        var baseType = enumSymbol.EnumUnderlyingType?.Name ?? "int";
        var members = enumSymbol.GetMembers()
            .Where(x => x is IFieldSymbol { ConstantValue: not null })
            .Select(x => new Member(x.Name, ((IFieldSymbol)x).ConstantValue))
            .ToArray();

        return new(
            name, @namespace, baseType, enumSymbol.DeclaredAccessibility,
            members,
            extensionClassNamespace,
            extensionClassName
        );
    }

    public string ToSourceCode()
    {
        var namespaceLine = _extensionClassNamespace is not null
            ? $"namespace {_extensionClassNamespace};"
            : HasNamespace
                ? $"namespace {_namespace};"
                : "";

        var className = _extensionClassName ?? $"{_name.ToFilename()}Extensions";

        var body = _isSequential ? ToSourceCodeSequential() : ToSourceCodeUnsequential();

        return $$"""
// <auto-generated/>

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

#nullable enable
{{namespaceLine}}

public static class {{className}}
{
{{body}}
{{ToSourceCodeCommon()}}
}
""";
    }

    private string ToSourceCodeCommon()
    {
        var declIsDefinedName = "bool IsDefined(ReadOnlySpan<char> name)";
        var declParse = $"{Fullname} Parse(ReadOnlySpan<char> name)";
        var declParseIgnoreCase = $"{Fullname} ParseIgnoreCase(ReadOnlySpan<char> name)";
        var declTryParse = $"bool TryParse(ReadOnlySpan<char> name, out {Fullname} value)";
        var declTryParseIgnoreCase = $"bool TryParseIgnoreCase(ReadOnlySpan<char> name, out {Fullname} value)";

        return $$"""
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{_baseType}} ToConstant(this {{Fullname}} value)
    {
        var i = Unsafe.As<{{Fullname}}, {{_baseType}}>(ref value);
        return i;
    }

{{MakeMethod(declIsDefinedName, (x, _) => $"nameof({x}): return true", inputValueName: "name", defaultCase: "return false")}}
{{MakeMethod(declParse,
    (x, _) => $"nameof({x}): return {x}",
    inputValueName: "name")}}
{{MakeMethod(declParseIgnoreCase,
    (x, _) => $$"""{ } when name.Equals(nameof({{x}}), StringComparison.OrdinalIgnoreCase): return {{x}}""",
    inputValueName: "name")}}
{{MakeMethod(declTryParse,
    (x, _) => $"nameof({x}): value = {x}; return true",
    inputValueName: "name",
    defaultCase: "value = default; return false")}}
{{MakeMethod(declTryParseIgnoreCase,
    (x, _) => $$"""{ } when name.Equals(nameof({{x}}), StringComparison.OrdinalIgnoreCase): value = {{x}}; return true""",
    inputValueName: "name",
    defaultCase: "value = default; return false")}}
""";
    }

    private string ToSourceCodeSequential()
    {
        return $$"""
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string ToName(this {{Fullname}} value)
    {
        var i = Unsafe.As<{{Fullname}}, {{_baseType}}>(ref value);
        return _names[i];
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined({{_baseType}} constant)
    {
        return ({{_unsignedBaseType}})constant < ({{_unsignedBaseType}})MembersCount;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsDefined({{Fullname}} value)
    {
        var i = Unsafe.As<{{Fullname}}, {{_baseType}}>(ref value);
        return IsDefined(i);
    }

{{MakeValues()}}
""";
    }

    private string ToSourceCodeUnsequential()
    {
        var declToName = $"string ToName(this {Fullname} value)";
        var declIsDefinedConstant = $"bool IsDefined({_baseType} constant)";
        var declIsDefinedValue = $"bool IsDefined({Fullname} value)";

        return $$"""
{{MakeMethod(declToName, (x, _) => $"{x}: return nameof({x})")}}
{{MakeMethod(declIsDefinedConstant, (x, y) => $"{y}: return true", inputValueName: "constant", defaultCase: "return false")}}
{{MakeMethod(declIsDefinedValue, (x, _) => $"{x}: return true", defaultCase: "return false")}}
{{MakeValues()}}
""";
    }

    private string MakeValues()
    {
        return $$"""
    public const int MembersCount = {{_members.Count}};
    {{_accessibility.ToCode()}} static ReadOnlySpan<{{Fullname}}> ValuesSpan => _values;
    {{_accessibility.ToCode()}} static ReadOnlySpan<string> NamesSpan => _names;
    {{_accessibility.ToCode()}} static ReadOnlySpan<{{_baseType}}> ConstantsSpan => _constants;
    {{_accessibility.ToCode()}} static IReadOnlyList<{{Fullname}}> Values => _values;
    {{_accessibility.ToCode()}} static IReadOnlyList<string> Names => _names;
    {{_accessibility.ToCode()}} static IReadOnlyList<{{_baseType}}> Constants => _constants;

    private static readonly {{Fullname}}[] _values = NewValues();
    private static readonly string[] _names = NewNames();
    private static readonly {{_baseType}}[] _constants = NewConstants();

    {{MakeNewValues()}}
""";
    }

    private string MakeNewValues()
    {
        return $$"""
private static {{Fullname}}[] NewValues()
    {
        return new {{Fullname}}[]
        {
        {{
            string.Join(",\n            ", _members.Select(MakeMemberFullName))
        }}
        };
    }

    private static string[] NewNames()
    {
        return new string[]
        {
        {{
            string.Join(",\n            ", _members.Select(x => MakeMemberFullName(x).SurroundWithNameOf()))
        }}
        };
    }

    private static {{_baseType}}[] NewConstants()
    {
        return new {{_baseType}}[]
        {
        {{
            string.Join(",\n            ", _members.Select(x => x.Value))
        }}
        };
    }
""";
    }

    private string MakeMethod(string decl, Func<string, object?, string> line,
        string inputValueName = "value",
        string defaultCase = "throw new ArgumentOutOfRangeException()")
    {
        return $$"""
    {{_accessibility.ToCode()}} static {{decl}}
    {
        switch ({{inputValueName}})
        {
{{ForEachMembers(line)}}
            default: {{defaultCase}};
        }
    }

""";
    }

    private string ForEachMembers(Func<string, object?, string> line)
    {
        var code = new StringBuilder();

        foreach (var member in _members)
        {
            var memberFullname = MakeMemberFullName(member);
            code.AppendLine($"            case {line(memberFullname, member.Value)};");
        }

        return code.ToString();
    }

    private string MakeMemberFullName(Member member)
    {
        return HasNamespace
            ? $"{_namespace}.{_name}.{member.Name}"
            : $"{_name}.{member.Name}";
    }

    private string MakeFilename()
    {
        if (_extensionClassNamespace is not null)
            return $"{_extensionClassNamespace}_{_extensionClassName ?? _name.ToFilename()}_EnumExtensions.g.cs";

        return HasNamespace
                ? $"{_namespace.ToFilename()}_{_extensionClassName ?? _name.ToFilename()}_EnumExtensions.g.cs"
                : $"{_extensionClassName ?? _name.ToFilename()}_EnumExtensions.g.cs";
    }

    private EnumUnit(
        string name, string @namespace, string baseType, Accessibility accessibility,
        IReadOnlyList<Member> members,
        string? extensionClassNamespace,
        string? extensionClassName)
    {
        _name = name;
        _namespace = @namespace;
        _baseType = baseType;
        _accessibility = accessibility;
        _members = members;
        _extensionClassNamespace = extensionClassNamespace;
        _extensionClassName = extensionClassName;

        _unsignedBaseType = Helper.ToUnsignedType(baseType);
        _isSequential = IsSequential(members, _baseType);
    }

    private static bool IsSequential(IReadOnlyList<Member> members, string baseType)
    {
        for (var i = 0; i != members.Count; ++i)
        {
            var v = members[i].Value;
            if (v is null)
                throw new NotImplementedException();

            if (Helper.IsEqual(i, v, baseType) == false)
                return false;
        }

        return true;
    }

    private sealed class Member
    {
        public readonly string Name;
        public readonly object? Value;

        public Member(string name, object? value)
        {
            Name = name;
            Value = value;
        }
    }
}